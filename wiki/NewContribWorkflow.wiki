#summary Design of a new way for volunteers to easily find things that need doing, and to do them.
#labels Phase-Design

= Introduction =

Currently, when someone decides they'd like to volunteer with !AdBlock, they are pointed to HowToContribute.  That document is a big mix of instructions that, to someone who knows nothing about the project structure, can seem daunting and vague.  Michael gets the impression that people don't know where to start, and end up not starting at all.

I'd like to replace that with a workflow that breaks tasks into simple, discrete chunks, and provides volunteers with a menu of tasks to complete, each with simple instructions.  That would help casual volunteers who may want to help once, or once a month, so that they can offer their contribution without having to learn everything about the project.  It would also help long-time contributors to the project (myself included), by providing a dashboard of what work is falling through the cracks.

<wiki:toc max_depth="2" />

= Strategy =

Create the Volunteer UI: a single web page where all volunteers can be directed, new and veteran alike.  It has a link to an overview of the project and helping out, a list of tasks that can be performed, and a Dashboard showing some high-level info to act upon.  This probably can't be a Project Hosting wikipage because they're too limited, so it should be a standalone page.

There are a few parts to the strategy.

== The pipeline ==

Some users may feel comfortable reproducing a bug but not finding the root cause.  Others may enjoy finding the root cause, or reviewing a patch to fix it, but wouldn't be confident writing the patch.  Some may only want to due initial Issue triage, marking Duplicates or asking for clarification from users.  Finally, some people who normally would want to write code may need a change of pace, and would enjoy just gathering clarification for a while.

Using a pipeline metaphor would help support these volunteers, allowing many people contribute a little to closing an Issue.  This also lets volunteers use their most in-demand skills most of the time (e.g. rather than a veteran volunteer triaging, clarifying, reproing, debugging, and fixing an issue, she may spend most of her time fixing and code reviewing issues.)

*Here's how the pipeline could work:*

Volunteers are presented with a list of tasks they could perform, e.g. "Reproduce a bug" or "Triage a new Issue."

Selecting one of these tasks would show three things:

  # The *list of Issues that need that task done*.  Every task should have an associated label or status in the Issue tracker, so that this list can be created with a custom search.  E.g. 'Repro-Unknown' Issues need repro.  (This means we'll need to change our existing flow, and convert the few hundred existing open Issues to the new flow.)
  # A link to detailed instructions for *how to accomplish the task*.  E.g. exactly how one goes about reproducing a bug.  It's a link rather than inline, so that once the volunteer understands the instructions, they don't clutter up the UI.
  # Instructions for *how to modify the Issue when done with the task*.  E.g. label it `Repro-Confirmed` or comment that you failed to reproduce the bug.  Changing the label would likely remove it from the list in step 2 and add it to a list for a different task.

Can you picture it?  There's a pipeline of stages that each Issue has to flow through, from Task 1 through Task N.  People can hop in at any stage and help move some issues to the next stage in the pipeline.  And because each stage is defined by labels, we should be able to quickly see which stage has the most Issues accumulated waiting for help.

== Dashboard ==

Today, if an issue gets commented upon but not followed up, it just grows stale in the tracker.  Ideally, we'd know exactly which Issues still need attention, and work to close them.

So we have a dashboard, which is just a few more custom searches, like the Issue lists in the pipeline.  It allows everyone to see which Issues are languishing, so that it's immediately obvious to a newcomer which ones need the most help.  See the Details below for what the Dashboard might show.

== Automation ==

Write scripts to automate absolutely everything that can be automated, so volunteers can focus time on applying their skills rather than performing drudge work.  See the Details below for things we could automate.

= Details =

== Lifecycle of an Issue ==

The most common and complex Issue type is Type-Defect, whose stages are:

  # `Status:New` - _just filed_
  # `Status:Accepted` - _we didn't set it to `:Invalid :WontFix :Duplicate`_
    * (Gets default labels: `Repro-Unknown` `Cause-Unknown` `Clarity-Unknown`)
    * `Clarity-WaitingForUser` - _waiting for a reply to clarify the Issue.  Used to be called `MoreInfoNeeded`._
    * `Clarity-Clear` - _no more info needed from user to proceed_
    * `Repro-Confirmed` - _bug was reproduced_
    * `Cause-Known` - _root cause of bug discovered_
  # `Status:Coding` `Owner:(somebody)` - _enough is understood that someone is writing code to fix the Issue_
    * (Gets default labels: `Repro-Unknown` `Cause-Known` `Clarity-Clear` if not otherwise specified)
    * `CodeReview-NeedsReview` - _Owner is done coding, needs code review_
    * `CodeReview-NeedsWork` - _Code reviewer found problems, back to Owner_
  # `Status:ReadyForRelease` - _Code reviewer feels it's ready to merge_
  # `Status:Fixed` - _Merged into trunk_
  # `Status:Invalid/Duplicate/FailedToReproduce/WontFix` - _closed without Fixing_

Ownership means "I'm working on this; nobody touch it but me".  The purpose is to avoid duplication of effort.  Note that only `Status:Coding` requires an Owner, but a user can become Owner to find the root cause if it looks tricky (again to avoid duplication of effort).  Users may assign only themselves as Owner of an Issue, and may unassign if they don't want to keep working on it.

== Pipeline ==

This is the main section of the volunteer UI, displaying each stage in the pipeline as a task to complete.  Each task lists Issues in that stage, from oldest-Modified to newest.

Below is the list of tasks, along with the *search* that defines the list of relevant Issues and a *numbered list of transformations* the volunteer can perform on an Issue to move it to another stage.

(Note: at any stage a user can close an issue as `Status:Invalid` or `Status:WontFix`, so they're mostly not listed below.)

  # *Create a bug report*.  It is set to `Status:New` `Type-Defect`/`Type-FeatureRequest`.
  # *Triage a new Issue*
    * Search: `Status:New` -`Owner`
    # `Status:Duplicate/Invalid/WontFix`
    # `Status:Accepted`
    # Change `Type` to `AdReport/FeatureRequest/Defect`
  # *Clarify an Issue*
    * Search: `Status:Accepted` -`Owner` -`Clarity-Clear`.  _(Divided into `Clarity-Unknown` and `Clarity-WaitingForUser`, so volunteers can choose whether to ignore those already waiting for the user.)_
    # ask question, `Clarity-WaitingForUser`, cc yourself so you notice when the reply comes back
    # _(if another user asked a question and forget to set `Clarity-WaitingForUser`):_ `Clarity-WaitingForUser`, cc the other user
    # `Clarity-Clear`
  # *Reproduce a bug report*
    * Search: `Status:Accepted` -`Clarity-WaitingForUser` `Cause-Unknown` `Repro-Unknown`
    # `Repro-Confirmed`
    # comment "Can't repro on (system, browser, version)"
    # `Browser-` or `OpSys-` labels
    # `Status:FailedToReproduce` to close the Issue after several people fail to repro
  # *Find the root cause of a bug*
    * Search: `Status:Accepted` -`Clarity-WaitingForUser` `Cause-Unknown` -Owner
    # `Cause-Known`, comment with explanation
    # `Owner:me`, if debugging looks tricky enough that duplication should be avoided
  # *Fix a bug*
    * Search: `Status:Accepted` `Clarity-Clear` `Repro-Confirmed` `Cause-Known` -Owner
    # `Status:Coding` `Owner:me`.  Set `CodeReview-NeedsReview` when done.
  # *Do code review*
    * Search: `Status:Coding` `CodeReview-NeedsReview`
    # `CodeReview-NeedsWork`, with comments on the revision(s); maybe cc yourself to review again
    # `Status:ReadyForRelease`
    # code review comments alone, if not confident to set to `Status:ReadyForRelease`
  # *Respond to a code review*
    * Search: `CodeReview-NeedsWork` `Owner:me`
    # -`Owner` (if you no longer can work on the Issue)
    # `CodeReview-NeedsReview`
  # (add your own task+search+transformations)

A fine point: users may want to filter out Issues that they personally don't care to address.  The Volunteer UI could be implemented as a webpage with a bunch of collapsed iframes embedding Project Hosting searches, so the page could modify the search to remove Issues that the User doesn't like.  But we may not want to allow that, as it will encourage volunteers to just filter out rather than address annoying Issues.

== Dashboard ==

The task list lets volunteers see a fine-grained view of the task they want to focus on.  There are also a few more general searches that might be helpful:

  # My open issues (`Owner:me`).  Owning an Issue tells others not to touch it, so the first thing a volunteer should do is to handle these or to release Ownership.  (`Owner:me` should maybe even appear above the task list.)
  # A list of all open issues ordered by Modified Date. The oldest will linger at the top of the list until we do something about it.
    * Michael thought about also having all open issues order by Modified Date descending, so we could see the newest issues easily, but maybe being forced to view Issues in oldest-to-newest order will encourage us to work to close old Issues.
  # We want to be aware very quickly of urgent issues.  We could try letting reporters opt in to having their issue labeled Urgent to appear in an Urgent list (and get emailed to interested parties, including Michael).  We can always unlabel Urgent if it's misapplied.  This may prove too spammy, but it can't hurt to try.
  # An 'unloved' list.  It contains issues that are stalled for a certain time, where the amount of time is different depending on the stage they're in.  Volunteers can periodically review unloved Issues and try to get some attention to them.  E.g. if an Issue hasn't moved from New to `Repro-Confirmed`,`Clarity-Clear` in X days, or doesn't get an Owner after Y days having been repro'd and clarified, or Z days with `CodeReview-NeedsReview` -- then it becomes 'unloved', and a reviewer can ping possible volunteers to help get to the next stage, or can do the work himself.  (Michael will review this list if nobody else does.)
  # (Add your own)

== Automation ==

Google Project Hosting has an API.  A robot could watch issue changes and take actions.  Here's the list so far:

  * Issues with 'urgent' in subject get labeled Urgent, emails sent to interested parties
  * Issues with `Clarity-WaitingForUser` become `Clarity-Unknown` when a non-project-member replies
  * Issues with `Clarity-WaitingForUser` become `Status:Invalid`, `Restrict-Comment-Commit` after X days with no reply; adds comment explaining how to refile if desired
  * Issues with `Status:Coding` but no owner become `Status:Accepted`, with a comment explaining that an Owner is needed
    * _(Michael doesn't like this much.  It's dumb that `Status:Coding` requires `Owner`, but he can't think of a better workflow.)_
  * Issues with an Owner lose the Owner after X days with no activity; adds comment asking for someone to take ownership when they have time to work on the Issue
  * Issues that arrive on the 'unloved' Dashboard list could get emailed to afc-dev, so we are driven to close the bugs to shut up the nag emails?
  * New issues with nothing filled in become `Status:Invalid`, `Restrict-Comment-Commit` with a comment explaining how to file a bug
  * (add your own)

= Problems =

Problems with the above:

  * It'll take a little work to get used to the new labels.  Google Project Hosting will help with that some, because e.g. "Status:!NeedsReview" will no longer turn green when you type it, reminding you to use the label "!CodeReview-!NeedsReview" instead.
  * (add your own)